#!/bin/sh
# vim: set ft=bash:
# shellcheck disable=1090,1091
# This file is *not* executable as it is sourced by
# the rc.boot and rc.shutdown scripts.

log() {
    printf '\033[31;1m=>\033[m %s\n' "$@"
}

mnt() {
    mounted "$1" && return 0
    dir=$1
    shift
    mount "$@" "$dir"
}

mounted() {
    # This is a pure shell mountpoint implementation. We're dealing
    # with basic (and fixed/known) input so this doesn't need to
    # handle more complex cases.
    [ -e "$1" ]         || return 1
    [ -e /proc/mounts ] || return 1

    while read -r _ target _; do
        [ "$target" = "$1" ] && return 0
    done < /proc/mounts

    return 1
}

sos() {
    log "Init system encountered an error, starting emergency shell." \
        "When ready, type 'exit' to continue the boot."

    /bin/sh -l
}

save_random() {
    log "This may hang."
    log "Mash the keyboard to generate entropy..."

    dd count=1 bs=512 if=/dev/random of=/var/random.seed 2>/dev/null
}

parse_crypttab() {
    # This is a pure shell crypttab parser which supports
    # a subset of the format.
    exec 3<&0

    # shellcheck disable=2086
    while read -r name dev pass opts err; do
        # Skip comments.
        [ "${name##\#*}" ] || continue

        # Break on invalid crypttab (> 5 columns).
        [ "$err" ] && {
            printf 'error: A valid crypttab has only 4 columns.\n'
            break
        }

        # Turn 'UUID=*', 'LABEL=*', 'PARTUUID=*' lines into device names.
        case ${dev%%=*} in UUID|LABEL|PARTUUID)
            set -f; for line in $(blkid); do
                case ${line%%=*} in
                    /dev/*)
                        _dev=${line%:}
                    ;;

                    UUID|LABEL|PARTUUID)
                        [ "$_dev" ] || continue

                        _line=${line##*=}
                        _line=${_line%\"}
                        _line=${_line#\"}

                        [ "$_line" = "${dev##*=}" ] && {
                            dev=${_dev}
                            break
                        }
                    ;;
                esac
            done; set +f
        esac

        # Sanity check.
        case "$dev" in /dev/*) ;; *) sos; esac

        # Parse options by turning the list into a pseudo array.
        { old_ifs=$IFS; IFS=,; set -f; set +f -- $opts; IFS=$old_ifs; }

        # Create an argument list (no other way to do this in sh).
        for opt; do case $opt in
            discard)            copts="$copts --allow-discards" ;;
            readonly|read-only) copts="$copts -r" ;;
            tries=*)            copts="$copts -T ${opt##*=}" ;;
        esac; done

        # If password is 'none', '-' or empty ask for it.
        case $pass in
            none|-|"") cryptsetup luksOpen $copts "$dev" "$name" <&3 ;;
            *)         cryptsetup luksOpen $copts -d "$pass" "$dev" "$name" ;;
        esac
    done < /etc/crypttab

    exec 3>&-

    [ "$copts" ] && [ -x /bin/vgchange ] && {
        log "Activating LVM devices for dm-crypt..."
        vgchange --sysinit -a y || sos
    }
}
